Как я поняла алгоритм:
Пишем А | E
Каждый раз обе части домножаем на матрицу отражения U(x), которая равна Е - 2xx*
При этом если на каком-то шаге матрица U(x) была вида
1 0 0 0 ... 0 0 0 0
0 1 0 0 ... 0 0 0 0
0 0 1 0 ... 0 0 0 0
...
0 0 ... 0 c[kk] c[k(k+1)] ... c[kn]
0 0 ... 0 c[(k+1)k] ..... c[(k+1)n]
...
0 0 ... 0 c[nk] c[n(k+1)] ... c[nn]
Тогда в следующий раз матрица U(x) будет вида
1 0 0 0 ... 0 0 0 0
0 1 0 0 ... 0 0 0 0
0 0 1 0 ... 0 0 0 0
...
0 0 ... 0 d[(k+1)(k+1)] ... d[(k+1)n]
0 0 ... 0 d[(k+2)(k+1)] ... d[(k+2)n]
...
0 0 ... 0 d[n(k+1)] d[n(k+2)] ... d[nn]
То есть если матрица А в левой части на каком-то шаге была вида
||a1|| a'[12] a'[13] ... a'[1n]
0 ||a2|| a'[22] a'[23].. a'[2n]
...
0 0 ...||a(k-1)|| a'[(k-1)k].. a'[(k-1)n]
0 0 ... 0 c[kk] c[k(k+1)] ... c[kn]
0 0 ... 0 c[(k+1)k] ..... c[(k+1)n]
...
0 0 ... 0 c[nk] c[n(k+1)] ... c[nn]
То на следующем будет вида
||a1|| a'[12] a'[13] ... a'[1n]
0 ||a2|| a'[22] a'[23].. a'[2n]
...
0 0 ...||a(k)|| a'[k(k+1)].. a'[kn]
0 0 ... 0 c[(k+1)(k+1)] ..... c[(k+1)n]
0 0 ... 0 c[(k+2)(k+1)] ..... c[(k+2)n]
...
0 0 ... 0 c[n(k+1)] c[n(k+2)] ... c[nn]

Сам алгоритм,что именно надо прогать
Надо научиться умножать матрицу U(x) на какую-то другую А
если а[i] - столбцы матрицы А, то согласно правилам умножения
U(x)A=U(x)(a[1], a[2], ..., a[n]) = (U(x)a[1], U(x)a[2], ..., U(x)a[n])
Короче надо научиться умножать U(x) на вектор(столбец) назовем ее у. Тогда
U(x)y = (E - 2xx*)y = y - 2x((x*)y) = y - 2x(x, y)
То есть считаем скалярное произведение векторов x, y. Это число. Умножаем вектор x на число 2*(x, y). Полученный вектор вычитаем из у.
Такой формулой мы каждый раз умножаем матрицу U(x) на каждый вектор матрицы. 

Те же самые преобразования делаем с матрицей А и с матрицей Е.
В конце получаем C | D. Где С - верхнетреугольная матрица. Ну и обратным ходом метода Гаусса приводим к виду Е | F, где Е - единичная. 
F - ответ.
